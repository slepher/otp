%%-------------------------------------------------------------------
%% @author Chen Slepher <slepheric@gmail.com>
%% @copyright (C) 2017, Chen Slepher
%% Created : 18 Sep 2017 by Chen Slepher <slepheric@gmail.com>
%% @end
%%-------------------------------------------------------------------
%% @doc `erl_parse' trees traverse.
%%
%% This module provide a series method to traverse `erl_parse' trees
%% such as {@link map/3}, {@link reduce/4}, {@link map_with_state/4}, {@link mapfold/4}.
-module(erl_abs).

-include("abs_struct_name.hrl").

%% API
-export([map/2, map/3]).
-export([map_with_state/3, map_with_state/4]).
-export([reduce/3, reduce/4]).
-export([mapfold/3, mapfold/4]).
-export([without_errors/1]).
-export([map_m/3]).
-export([sort_forms/1, insert_forms/2]).
-export([format_error/1]).

-type traverse_node() :: tuple().
-type traverse_error() :: term().
-type traverse_state() :: term().

%%  @type traverse_opts() = #{traverse => TraverseStyle,
%%                            parse_transform => ParseTransform::boolean(),
%%                            simplify_return => boolean(), parent => atom(),
%%                            children => boolean(),
%%                            sequence_children => fun((any()) -> any()),
%%                            transform => fun((any()) -> any()),
%%                            syntax_lib => SyntaxLib::module(),
%%                            node => NodeType, formatter => module() }.
%%
%% <dl><dt>TraverseStyle = pre | post | leaf | all | list, How to traverse ast</dt>
%% <dd><ul>
%%   <li>pre : Traverse parent ast first, then its subtrees.</li>
%%   <li>post : Traverse ast subtrees first, then traverse new parent ast generated by new subtrees.</li>
%%   <li>leaf : Only traverse ast leaf.</li>
%%   <li>all : Traverse parent ast first, then its subtress, then traverse new parent ast generated by new subtrees.</li>
%%   <li>list : Only traverse one level subtrees of ast.</li>
%% </ul></dd>
%% <dt>ParseTransform : only used in map/3 and map_with_state/4, convert the return value of function to parse_transform/2 compatible type.</dt>
%% <dt>SimplyfyReturn : default to false.</dt>
%% <dd><ul>
%% <li>true : Just return the return value if there is no error and warning in traverse</li>
%% <li>false = return full erl_abs_return struct</li>
%% </ul></dd>
%% <dt>Parent = pass to traverse_attr() node tag, default to form.</dt>
%% <dt>Children = boolean(), default to false.</dt>
%% <dd><ul>
%% <li>true = Only traverse children of node, not traverse node its self</li>
%% <li>false = traverse node its self and its children</li>
%% </ul></dd>
%% <dt>SyntaxLib = which syntax lib is used by, default to erl_abs_syntax.</dt>
%% <dt>Formatter = error formatter module which provide format_error/1, default is erl_syntax_traverse</dt>
%% </dl>

-type traverse_opts() :: #{traverse => traverse_style(),
                           parse_transform => boolean(),
                           simplify_return => boolean(), parent => atom(),
                           children => boolean(),
                           sequence_children => fun((any()) -> any()),
                           transform => fun((any()) -> any()),
                           syntax_lib => module(),
                           node => node_type(), formatter => module() }.

-type traverse_error_state() :: #{file => string(), errors => traverse_return_error(), warnings => traverse_return_error(),
                                  file_errors => parse_transform_return_error(), 
                                  file_warnings => parse_transform_return_error()}.

-type node_type() :: attribute | pattern | expression | guard | form.
-type traverse_style() :: traverse_step() | all | list.
-type traverse_step() :: pre | post | leaf.
-type traverse_attr() :: #{step := traverse_step(), node := node_type()}.
-type traverse_fun_return() :: #{'__struct__' := erl_syntax_traverse_fun_return, 
                                 node => traverse_node(), state => traverse_state(),
                                 continue => boolean(),
                                 error => traverse_error(), warning => traverse_error(),
                                 errors => [traverse_error()], warings => [traverse_error()]} |
                               {error, traverse_error()} | {warning, traverse_node(), traverse_error()} |
                               continue | {traverse_node(), traverse_state()} | traverse_node().

-type traverse_return(ReturnType) :: ReturnType | 
                                     {ok, ReturnType, traverse_error_state()} |
                                     {error, traverse_error_state()}.

-type traverse_final_return(ReturnType) :: traverse_return(ReturnType) | parse_transform_return(ReturnType).

-type parse_transform_return(ReturnType) :: ReturnType |  {warning, ReturnType, parse_transform_return_error()} |
                                            {error, parse_transform_return_error(), parse_transform_return_error()}.

-type traverse_fun() :: fun((traverse_node(), traverse_attr()) -> traverse_fun_return()).
-type traverse_state_fun() :: fun((traverse_node(), traverse_state(), traverse_attr()) -> traverse_fun_return()).
-type parse_transform_module() :: module().
-type compile_file() :: string().
-type line() :: integer().
-type traverse_return_error() :: [{line(), parse_transform_module(), traverse_error()}].
-type parse_transform_return_error() :: [{compile_file(), traverse_return_error()}].

%%===================================================================
%% API
%%===================================================================
-spec map(traverse_fun(), Node) -> traverse_final_return(Node).
%% @see map/3
map(F, TopNode) ->
    map(F, TopNode, #{}).

-spec reduce(traverse_state_fun(), State, _Node) -> traverse_return(State).
%% @see reduce/4
reduce(F, Init, TopNode) ->
    reduce(F, Init, TopNode, #{}).

-spec map_with_state(traverse_state_fun(), State, Node) -> traverse_final_return({Node, State}).
%% @see map_with_state/4
map_with_state(F, Init, Form) ->
    map_with_state(F, Init, Form, #{}).

-spec mapfold(traverse_state_fun(), State, Node) -> traverse_return({Node, State}).
%% @see mapfold/4
mapfold(F, TopAst, Node) ->
    mapfold(F, TopAst, Node, #{}).

%% @spec map(traverse_fun(), TopAstA, Opts) -> traverse_final_return(TopAstB)
%%           traverse_fun() = fun((AstNodeA, Attr) -> traverse_fun_return(AstNodeB))
%% @doc
%% Takes a function from AstNodeA, {@link traverse_attr()} to AstNodeB, and a TopAstA and produces a TopAstB by applying the function to every subtree in the AST. This function is used to obtain the return values.
%% @see mapfold/4
-spec map(traverse_fun(), Node, traverse_opts()) -> traverse_final_return(Node).
map(F, TopAst, Opts) ->
    F1 = fun(Node, _State, Attr) ->
                 Return = F(Node, Attr),
                 erl_abs_walk_return:new(fun() -> #{node => Return} end, Return)
         end,
    map_with_state(F1, ok, TopAst, Opts).

%% @spec reduce(traverse_state_fun(), Acc0, TopAst, Opts) -> traverse_return(Acc1)
%%              traverse_state_fun() = fun((AstNode, AccA, Attr) -> traverse_fun_return(AccB))
%% @doc
%% Calls F(AstNode, AccIn, Attr) on successive subtree AstNode of TopAst, starting with AccIn == Acc0. F/3 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the TopAst is empty.
%% @see mapfold/4
-spec reduce(traverse_state_fun(), State, _Node, traverse_opts()) -> traverse_return(State).
reduce(F, Acc0, TopAst, Opts) ->
    NF = fun(Node, State, Attr) ->
                 Return = F(Node, State, Attr),
                 erl_abs_walk_return:new(fun() -> #{state => Return} end, Return)
         end,
    Transform = fun({_NNode, State}) -> State end,
    mapfold(NF, Acc0, TopAst, merge_transform(Transform, Opts)).

%% @spec map_with_state(traverse_state_fun(), Acc0, TopAst0, Opts) -> traverse_final_return(TopAst1)
%%                      traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass, and drops Acc1.
%% @see mapfold/4
-spec map_with_state(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_final_return({Node, State}).
map_with_state(F, Acc0, TopAst, Opts) ->
    Transform = fun({NNode, _State}) -> NNode end,
    mapfold(F, Acc0, TopAst, merge_transform(Transform, Opts)).

merge_transform(Transform, #{transform := Transform1} = Opts) ->
    Transform2 = 
        fun(Data) ->
            Transform1(Transform(Data))
        end,
    Opts#{transform => Transform2};
merge_transform(Transform, #{} = Opts) ->
    Opts#{transform => Transform}.

%% @spec mapfold(traverse_state_fun(), Acc0, TopAst0, traverse_opts()) -> traverse_return({TopAst1, Acc1})
%%               traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass.
-spec mapfold(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_return({Node, State}).
mapfold(F, Init, TopAst, Opts) ->
    Formatter = maps:get(formatter, Opts, ?MODULE),
    Opts1 = maps:without([simplify_return, transform, parse_transform, formatter], Opts),
    NF = erl_abs_traverse_m:transform_mapfold_f(F),
    TopAstM = map_m(NF, TopAst, Opts1),
    Return = erl_abs_traverse_m:run(TopAstM, Formatter, Init),
    transform_return(Return, Opts).

transform_return(Return, Opts) ->
    Return1 =
        case maps:find(transform, Opts) of
            {ok, Transform} ->
                erl_abs_monad:lift_m(Transform, Return);
            error ->
                Return
        end,
    case maps:get(parse_transform, Opts, false) of
        true ->
            erl_abs_return:to_compiler(Return1);
        false ->
            case maps:get(simplify_return, Opts, true) of
                true ->
                    Return2 = erl_abs_return:simplify(Return1),
                    Return2;
                false ->
                    Return1
            end
    end.

without_errors(Forms) ->
    map(fun(Node, #{}) -> Node end, Forms, #{traverse => form, formatter => ?MODULE, simplify_return => false}).

-spec map_m(traverse_fun(), Node, traverse_opts()) -> erl_abs_return:struct(Node).
map_m(F, Nodes, Opts) when is_list(Nodes) ->
    F1 = up_f_by_traverse(F, Opts),
    case is_forms(Nodes) of
        true ->
            map_forms(F1, Nodes, Opts);
        false ->
            map_m_2(F, Nodes, Opts)
    end;
map_m(F, Node, Opts) ->
    NF = up_f_by_traverse(F, Opts),
    map_m_2(NF, Node, Opts).

-spec map_forms(fun((erl_syntax:syntaxTree()) -> erl_abs_traverse_m:struct(_A)), [erl_syntax:syntaxTree()], #{}) ->
                       erl_abs_traverse_m:struct(erl_syntax:syntaxTree()).
%% if a list variable is reversed, there is a R suffix after variable name.
%% if a variable is a monad, there is a M suffix after variable name.
map_forms(Fun, Forms, Opts) ->
    Functions = forms_functions(Forms),
    map_forms(Fun, Forms, Functions, erl_abs_traverse_m:return({[], []}), Opts).

map_forms(Fun, [{error, _Error} = Form|Tails], Functions, HeadsRM, Opts) ->
    map_forms(Fun, Tails, Functions, append_to_headsrm(Form, HeadsRM), Opts);
map_forms(Fun, [{warning, _Error} = Form|Tails], Functions, HeadsRM, Opts) ->
    map_forms(Fun, Tails, Functions, append_to_headsrm(Form, HeadsRM), Opts);
map_forms(Fun, [{attribute, _Line, file, {File, _Line}} = Form|Tails], Functions, HeadsRM, Opts) ->
    erl_abs_traverse_m:then(
      erl_abs_traverse_m:update_file(File),
      map_forms(Fun, Tails, Functions, append_to_headsrm(Form, HeadsRM), Opts));
map_forms(Fun, [{eof, _Line} = Form|Tails], Functions, HeadsRM, Opts) ->
    erl_abs_traverse_m:then(
      erl_abs_traverse_m:eof(),
      map_forms(Fun, Tails, Functions, append_to_headsrm(Form, HeadsRM), Opts));
map_forms(Fun, [Form|Tails], Functions0, HeadsRM, Opts) ->
    erl_abs_traverse_m:bind(
      HeadsRM,
      fun(HeadsR) ->
              erl_abs_traverse_m:bind(
                erl_abs_traverse_m:catch_updated_nodes(apply_fun(Fun, Form, Opts)),
                fun({_, false}) ->
                        map_forms(Fun, Tails, Functions0, append_to_headsrm(Form, HeadsRM), Opts);
                   ({NewForms, true}) ->
                        NewFormsFunctions = new_forms_functions(Form, NewForms),
                        {Functions1, HeadsR1, Tails2} =
                            insert_forms(NewForms, NewFormsFunctions, Functions0, HeadsR, Tails),
                        map_forms(Fun, Tails2, Functions1, erl_abs_traverse_m:return(HeadsR1), Opts)
                end)
      end);
map_forms(_Fun, [], _Acc, FormsM, _Opts) ->
    erl_abs_monad:lift_m(
      fun({FHeadsR, AHeadsR}) ->
              lists:reverse(AHeadsR) ++ lists:reverse(FHeadsR)
      end, FormsM).

append_to_headsrm(Form, HeadsRM) ->
    erl_abs_monad:lift_m(fun(HeadsR) -> append_to_headsr(Form, HeadsR) end, HeadsRM).

append_to_headsr({attribute, _Line, spec, _SpecValue} = Spec, {FHeadsR, AHeadsR}) ->
    {[Spec|FHeadsR], AHeadsR};
append_to_headsr({function, _Line, _Name, _Arity, _Clauses} = Function, {FHeadsR, AHeadsR}) ->
    {[Function|FHeadsR], AHeadsR};
append_to_headsr({eof, _Line} = Eof, {FHeadsR, AHeadsR}) ->
    {[Eof|FHeadsR], AHeadsR};
append_to_headsr(Form, {[], AHeadsR}) ->
    {[], [Form|AHeadsR]};
append_to_headsr(Form, {FHeadsR, AHeadsR}) ->
    {[Form|FHeadsR], AHeadsR}.

apply_fun(Fun, Form, #{traverse := form}) ->
    TraverseM =
        case apply_f(Fun, Form) of
            #{?STRUCT_KEY := ?TRAVERSE_M} = Traverse ->
                Traverse;
            #{?STRUCT_KEY := ?RETURN_OK} = Return ->
                erl_abs_traverse_m:erl_abs_traverse_m(Return);
            #{?STRUCT_KEY := ?RETURN_FAIL} = Return ->
                erl_abs_traverse_m:erl_abs_traverse_m(Return);
            Return ->
                erl_abs_traverse_m:erl_abs_traverse_m(erl_abs_walk_return:new(Return))
        end,
    erl_abs_traverse_m:update_line(erl_syntax:get_pos(Form), TraverseM);
apply_fun(Fun, Form, Opts) ->
    map_m_1(Fun, Form, Opts).

apply_f(Fun, Form) when is_function(Fun, 1) ->
    Fun(Form);
apply_f(Fun, Form) when is_function(Fun, 2) ->
    Fun(Form, #{}).

%% =====================================================================
%% detect new forms functions
%% =====================================================================
new_forms_functions(Form, NewForms) ->
    FormFunctions = forms_functions([Form]),
    NewFormsFunctions = forms_functions(NewForms),
    ordsets:subtract(NewFormsFunctions, FormFunctions).

forms_functions(Forms) ->
    forms_functions(Forms, ordsets:new()).

forms_functions(Forms, Functions0) ->
    lists:foldl(
      fun({function, _Line, Name, Arity, _Clauses}, Acc) ->
              ordsets:add_element({Name, Arity}, Acc);
         (_Node, Acc) ->
              Acc
      end, Functions0, Forms).

%% @spec sort_forms([erl_syntax:syntaxTree()]) -> [erl_syntax:syntaxTree()]
%% @doc sort forms to valid order, same as insert_forms(Forms, []).
%% @see insert_forms/2.
-spec sort_forms([erl_syntax:syntaxTree()]) -> [erl_syntax:syntaxTree()].
sort_forms(Forms) ->
    insert_forms(Forms, []).

%% @spec insert_forms([erl_syntax:syntaxTree()], [erl_syntax:syntaxTree()]) -> [erl_syntax:syntaxTree()]
%% @doc insert new forms to froms with order fillow these rules
%% <ul>
%% <li>rename functions in forms which function has '__original__' call in it with same name and arity in new forms.</li>
%% <li>'__original__'(Args1, Args2, ...) will be transformed to RenamedFunction(Args1, Args2, ...).</li>
%% <li>after rename, it dose not matter function or spec with duplicated name and arity, lint will get these errors.</li>
%% <li>attribute in new forms will insert before first spec or function or eof.</li>
%% <li>spec in new forms will insert before function with same name and arity or eof.</li>
%% <li>function in new forms will insert after spec with same name and arity or insert before eof.</li>
%% <li>eof_marker in new forms will be dropped if there is an eof_marker already exists in forms.</li>
%% <li>eof_marker in new forms will insert at the end of forms if there is no eof_market in forms.</li>
%% <li>if form is marked from other file (between -file(file1) and -file(file2)), do not change this mark.(not implemented)</li>
%% </ul>
%% @end
-spec insert_forms([erl_syntax:syntaxTree()], [erl_syntax:syntaxTree()]) -> [erl_syntax:syntaxTree()].
insert_forms(NewForms, Forms) ->
    Functions = forms_functions(Forms),
    NewFormsFunctions = forms_functions(NewForms),
    HeadsR = lists:foldl(fun append_to_headsr/2, {[], []}, Forms),
    {_Functions, {FHeadsR, AHeadsR}, Tails} = insert_forms(NewForms, NewFormsFunctions, Functions, HeadsR, []),
    lists:reverse(AHeadsR) ++ lists:reverse(FHeadsR) ++ Tails.

%% merge forms rule
%% 1. rename functions which generated functions has '__original__' call in it with same name and arity.
%% 2. rename spec if new spec is generated
%% 3. for map_forms/2, code does not know how forms will change in tails
%$ 4. if it's need to adjust new generated form order, only forms in heads should be affeted
%% 5. new generated attribute should insert before first -spec in heads
%% 6. new generated spec should insert before function with same name and arity in heads
%% 7. new generated function should insert after spec with same name and arity in heads.
%% 8. if file of new generated form is different from oldone, file attribute should be created to mark file.
%% new_forms, heads, tails is original order.
%% after merge forms, Heads is reversed order, tails is original order.
insert_forms(NewForms, NewFormsFucntions, Functions, HeadsR, Tails) ->
    {Functions1, NewForms1, HeadsR1, Tails1} = merge_functions(NewForms, NewFormsFucntions, Functions, HeadsR, Tails),
    HeadsR2 = lists:foldl(fun form_insert_heads/2, HeadsR1, NewForms1),
    {Functions1, HeadsR2, Tails1}.

%% =====================================================================
%% merge functions
%% =====================================================================
merge_functions(NewForms, NewFormsFucntions, Functions, {FHeadsR, AHeadsR}, Tails) ->
    ExistsNewFunctions =
        ordsets:from_list(
          lists:filter(
            fun(NameArity) ->
                    ordsets:is_element(NameArity, Functions)
            end, ordsets:to_list(NewFormsFucntions))),
    Functions1 = ordsets:union(Functions, NewFormsFucntions),
    {Functions2, NewFormsR2, FHeadsR1, Tails1} =
        lists:foldl(
          fun({function, _Line, Name, Arity, _Clauses} = Form, {FunctionsAcc, NewFormsAcc, HeadsRAcc, TailsAcc}) ->
                  case ordsets:is_element({Name, Arity}, ExistsNewFunctions) andalso is_renamed(Arity, Form) of
                      true ->
                          NewName = new_function_name(Name, Arity, FunctionsAcc),
                          Form1 = update_call_name('__original__', NewName, Arity, Form),
                          HeadsRAcc1 = update_function_name(Name, Arity, NewName, HeadsRAcc),
                          TailsAcc1 = update_function_name(Name, Arity, NewName, TailsAcc),
                          {ordsets:add_element({NewName, Arity}, FunctionsAcc), [Form1|NewFormsAcc], HeadsRAcc1, TailsAcc1};
                      false ->
                          {FunctionsAcc, [Form|NewFormsAcc], HeadsRAcc, TailsAcc}
                  end;
             (Form, {FunctionsAcc, NewFormsAcc, HeadsAcc, TailsAcc}) ->
                  {FunctionsAcc, [Form|NewFormsAcc], HeadsAcc, TailsAcc}
          end, {Functions1, [], FHeadsR, Tails}, NewForms),
    {Functions2, lists:reverse(NewFormsR2), {FHeadsR1, AHeadsR}, Tails1}.

is_renamed(Arity, Form) ->
    erl_abs:reduce(
      fun({call, _Line1, {atom, _Line2, '__original__'}, Arguments}, Acc1, #{}) ->
              case length(Arguments) == Arity of
                  true ->
                      true;
                  false ->
                      Acc1
              end;
         (_Node, Acc1, #{}) ->
              Acc1
      end, false, Form, #{simplify_return => true, traverse => pre}).

new_function_name(FName, Arity, Functions) ->
    new_function_name(FName, Arity, Functions, 1).

new_function_name(FName, Arity, Functions, Counter) ->
    FName1 = list_to_atom(atom_to_list(FName) ++ "_" ++ integer_to_list(Counter)),
    case ordsets:is_element({FName1, Arity}, Functions) of
        true ->
            new_function_name(FName, Arity, Functions, Counter + 1);
        false ->
            FName1
    end.

update_function_name(Name, Arity, NewName, Forms) ->
    lists:map(
      fun({function, Line, FName, FArity, Clauses})
            when (FName == Name) andalso (FArity == Arity) ->
              Clauses1 =
                  lists:map(
                    fun(Clause) ->
                            update_call_name(Name, NewName, Arity, Clause)
                    end, Clauses),
              {function, Line, NewName, Arity, Clauses1};
         (Form) ->
              Form
      end, Forms).

update_call_name(OrignalName, NewName, Arity, Function) ->
    erl_abs:map(
      fun({call, Line, {atom, Line2, Name}, Arguments}, #{})
            when (Name == OrignalName) andalso (length(Arguments) == Arity) ->
              {call, Line, {atom, Line2, NewName}, Arguments};
         (Node, #{}) ->
              Node
      end, Function, #{traverse => pre, simplify_return => true}).

%% =====================================================================
%% form_insert_heads
%% =====================================================================
form_insert_heads({attribute, _Line, file, _FileValue} = File, HeadsR) ->
    append_to_headsr(File, HeadsR);
form_insert_heads({attribute, Line, export, Exports}, {FHeadsR, AHeadsR}) ->
    Exports1 = remove_duplicated_exports(Exports, FHeadsR),
    Exports2 = remove_duplicated_exports(Exports1, AHeadsR),
    case Exports2 of
        [] ->
            {FHeadsR, AHeadsR};
        _ ->
            Export = {attribute, Line, export, Exports2},
            {FHeadsR, [Export|AHeadsR]}
    end;
form_insert_heads({function, _Line1, Name, Arity, _Clauses} = Function, {FHeadsR, AHeadsR}) ->
    FHeadsR1 = insert_function_or_spec(function, Name, Arity, Function, FHeadsR),
    {FHeadsR1, AHeadsR};
form_insert_heads({attribute, _Line1, spec, {{Name, Arity}, _SpecType}} = Spec, {FHeadsR, AHeadsR}) ->
    FHeadsR1 = insert_function_or_spec(spec, Name, Arity, Spec, FHeadsR),
    {FHeadsR1, AHeadsR};
form_insert_heads({eof, _Line1}, {[{eof, _Line2} = Eof|FHeadsR], AHeadsR}) ->
    {[Eof|FHeadsR], AHeadsR};
form_insert_heads({eof, _Line} = Eof, {FHeadsR, AHeadsR}) ->
    {[Eof|FHeadsR], AHeadsR};
form_insert_heads(Attribute, {FHeadsR, AHeadsR}) ->
    {FHeadsR, [Attribute|AHeadsR]}.

remove_duplicated_exports(Exports1, [{attribute, _Line, export, Exports}|T]) ->
    Exports2 = Exports1 -- Exports,
    remove_duplicated_exports(Exports2, T);
remove_duplicated_exports(Exports, [_Form|T]) ->
    remove_duplicated_exports(Exports, T);
remove_duplicated_exports([], _Forms) ->
    [];
remove_duplicated_exports(Exports, []) ->
    Exports.

insert_function_or_spec(Type, Name, Arity, Form, HeadsR) ->
    insert_function_or_spec(Type, Name, Arity, Form, HeadsR, [], HeadsR).

insert_function_or_spec(function, Name, Arity, Function,
                        [{attribute, _Line, {{Name, Arity}, _SpecType}} = Spec|HeadsR], Tails, _InitHeadsR) ->
    lists:reverse(Tails) ++ [Function,Spec|HeadsR];
insert_function_or_spec(spec, Name, Arity, Spec,
                        [{function, _Line, Name, Arity, _Clauses} = Function|HeadsR], Tails, _InitHeadsR) ->
    lists:reverse(Tails) ++ [Function,Spec|HeadsR];
insert_function_or_spec(Type, Name, Arity, Form1, [Form|HeadsR], Tails, InitHeadsR) ->
    insert_function_or_spec(Type, Name, Arity, Form1, HeadsR, [Form|Tails], InitHeadsR);
insert_function_or_spec(_Type, _Name, _Arity, Form, [], _Tails, [{eof, _Line} = Eof|InitHeadsR]) ->
    [Eof,Form|InitHeadsR];
insert_function_or_spec(_Type, _Name, _Arity, Form, [], _Tails, InitHeadsR) ->
    [Form|InitHeadsR].

map_m_2(F, Nodes, Opts) ->
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:listen_nodes(map_m_1(F, Nodes, Opts)),
      fun({_, Nodes1}) when is_list(Nodes) ->
              erl_abs_traverse_m:return(Nodes1);
         ({_, [Node|_T]}) ->
              erl_abs_traverse_m:return(Node);
         ({_, []}) ->
              erlang:error({no_nodes_return, Nodes})
      end).

is_forms([Form|_T]) ->
    is_form(Form);
is_forms([]) ->
    false.

is_form(Nodes) when is_list(Nodes) ->
    false;
is_form(Form) ->
    case erl_syntax:type(Form) of
        attribute ->
            true;
        function ->
            true;
        error_marker ->
            true;
        warning_marker ->
            true;
        eof_marker ->
            true;
        _ ->
            false
    end.

up_f_by_traverse(F, #{traverse := pre}) ->
    fun(Node, #{step := pre  } = Attr) -> F(Node, Attr);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_abs_traverse_m:return(Node)
    end;
up_f_by_traverse(F, #{traverse := post}) ->
    fun(Node, #{step := pre  }) -> erl_abs_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post } = Attr) -> F(Node, Attr)
    end;
up_f_by_traverse(F, #{traverse := leaf}) ->
    fun(Node, #{step := pre  }) -> erl_abs_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_abs_traverse_m:return(Node)
    end;
up_f_by_traverse(F, _) ->
    F.

map_m_1(F, Nodes, Opts) when is_list(Nodes) ->
    erl_abs_traverse_m:sequence_either(
      lists:map(
        fun(Subtree) ->
                map_m_1(F, Subtree, Opts)
        end, Nodes));
map_m_1(F, NodeA, #{children := true} = Opts) ->
    Opts1 = maps:remove(children, Opts),
    SyntaxLib = syntax_lib(Opts1),
    Subtrees = SyntaxLib:subtrees(NodeA, Opts1),
    erl_abs_traverse_m:as_node(map_m_children(F, NodeA, Subtrees, Opts1, SyntaxLib));
map_m_1(F, NodeA, #{} = Opts) ->
    SyntaxLib = syntax_lib(Opts),
    map_m_tree_node(F, NodeA, Opts, SyntaxLib).

map_m_tree_node(_F, {error, Reason}, _Opts, _SyntaxLib) ->
    erl_abs_traverse_m:nodes([{error, Reason}]);
map_m_tree_node(F, NodeA, Opts, SyntaxLib) ->
    %% it's not a good way to mix attr with opts.
    Attr = maps:without([traverse], Opts),
    case SyntaxLib:is_file(NodeA) of
        false ->
            NodeType = SyntaxLib:node_type(NodeA, Opts),
            PreType = 
                case SyntaxLib:subtrees(NodeA, Opts) of
                    [] ->
                        leaf;
                    _Subtrees ->
                        pre
                end,
            erl_abs_traverse_m:bind_continue_nodes(
              apply_f(F, NodeA, Attr#{step => PreType, node => NodeType}, SyntaxLib),
              fun(NodeB) ->
                      case SyntaxLib:tps(NodeB, Opts) of
                          {_Type, _Pos, []} ->
                              erl_abs_traverse_m:insert_nodes([NodeB]);
                          {Parent, _Pos, Subtrees} ->
                              erl_abs_traverse_m:bind(
                                map_m_children(F, NodeB, Subtrees, Opts#{parent => Parent}, SyntaxLib),
                                fun(NodeC) ->
                                        erl_abs_traverse_m:set_continue(
                                          apply_f(F, NodeC, Attr#{step => post, node => NodeType}, SyntaxLib), false)
                                end)
                      end
              end);
        {file, File} ->
            erl_abs_traverse_m:then(
              erl_abs_traverse_m:update_file(File),
              apply_f(F, NodeA, Attr#{step => leaf, node => file}, SyntaxLib)
             )
    end.

apply_f(F, Node, Attr, SyntaxLib) ->
    Line = SyntaxLib:get_pos(Node),
    erl_abs_traverse_m:updated_node(
      Node, erl_abs_traverse_m:update_line(Line, F(Node, Attr))).

map_m_children(_F, Node, [], _Opts, _SyntaxLib) ->
    erl_abs_traverse_m:return(Node);

map_m_children(F, Node, Subtrees, Opts, SyntaxLib) ->
    Sequence = maps:get(sequence_children, Opts, fun erl_abs_traverse_m:deep_sequence_m/1),
    Opts1 = maps:remove(sequence_children, Opts),
    SyntaxType = SyntaxLib:type(Node),
    SubtreeMs = m_subtrees(F, Subtrees, Opts1#{parent => SyntaxType}),
    SubtreesM = Sequence(SubtreeMs),
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:listen_updated(SubtreesM),
      fun({_Subtrees1, false}) ->
              erl_abs_traverse_m:return(Node);
         ({Subtrees1, true}) ->
              Node1 = SyntaxLib:update_subtrees(Node, Subtrees1),
              erl_abs_traverse_m:return(Node1)
      end).

%% which syntax_lib used to visit type and subtrees 
syntax_lib(#{syntax_lib := SyntaxLib}) ->
    SyntaxLib;
syntax_lib(#{}) ->
    erl_abs_syntax.

m_subtrees(_F, {skip, Subtrees}, _Opts) when is_list(Subtrees) ->
    lists:map(
      fun(Subtree) ->
              erl_abs_traverse_m:insert_node(Subtree)
      end, Subtrees);
m_subtrees(_F, {skip, Subtree}, _Opts) ->
    erl_abs_traverse_m:insert_node(Subtree);
m_subtrees(F, {transformer, Subtree, Transformer}, Opts) ->
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:deep_sequence_m_1(m_subtrees(F, Subtree, Opts)),
      fun(Subtree1) ->
              Transformed = Transformer(Subtree1),
              erl_abs_traverse_m:insert_nodes(Transformed)
      end);
m_subtrees(F, {up_attr, Attr, Subtree}, Opts) when is_map(Attr) ->
    Opts1 = maps:merge(Opts, Attr),
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, {up_node, Node, Subtree}, Opts) when is_atom(Node) ->
    Opts1 = Opts#{node => Node},
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, Subtrees, Opts) when is_list(Subtrees) ->
    lists:map(
      fun(Subtree) ->
              m_subtrees(F, Subtree, Opts)
      end, Subtrees);
m_subtrees(F, Subtree, Opts) ->
    map_m_1(F, Subtree, Opts).

format_error({validate_key_failure, required, Key, _Value}) ->
    io_lib:format("option key ~p is required", [Key]);
format_error({validate_key_failure, {invalid_validator, Validator}, Key, _Value}) ->
    io_lib:format("validator ~p for option key ~p is invalid", [Validator, Key]);
format_error({validate_key_failure, {invalid_validator_arg, {Validator, Arg}}, Key, _Value}) ->
    io_lib:format("argument ~p of validator ~p for option key ~p is invalid", [Arg, Validator, Key]);
format_error({validate_key_failure, {invalid_validator_arg, Validator}, Key, _Value}) when is_atom(Validator) ->
    io_lib:format("argument of validator ~p for option key ~p is empty", [Validator, Key]);
format_error({validate_key_failure, {invalid_value, Validator}, Key, Value}) ->
    io_lib:format("validator ~p for option key ~p's value ~p failed", [Validator, Key, Value]);
format_error({validate_key_failuer, {invalid_validator_return, Validator, Return}, Key, _Value}) ->
    io_lib:format("validator ~p for option key ~p returns a invalid_value ~p", [Validator, Key, Return]);
format_error({invalid_option_value, Value}) ->
    io_lib:format("~p is not a valid option value", [Value]);
format_error(Message) ->
    case io_lib:deep_char_list(Message) of
        true -> Message;
        _    -> io_lib:write(Message)
    end.
