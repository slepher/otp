%%-------------------------------------------------------------------
%% @author Chen Slepher <slepheric@gmail.com>
%% @copyright (C) 2017, Chen Slepher
%% Created : 18 Sep 2017 by Chen Slepher <slepheric@gmail.com>
%% @end
%%-------------------------------------------------------------------
%% @doc `erl_parse' trees traverse.
%%
%% This module provide a series method to traverse `erl_parse' trees
%% such as {@link map/3}, {@link reduce/4}, {@link map_with_state/4}, {@link mapfold/4}.
-module(erl_abs).

-include("abs_struct_name.hrl").

%% API
-export([map/2, map/3]).
-export([map_with_state/3, map_with_state/4]).
-export([reduce/3, reduce/4]).
-export([mapfold/3, mapfold/4]).
-export([without_errors/1]).
-export([map_m/3]).
-export([format_error/1]).

-type traverse_node() :: tuple().
-type traverse_error() :: term().
-type traverse_state() :: term().

%%  @type traverse_opts() = #{traverse => TraverseStyle,
%%                            parse_transform => ParseTransform::boolean(),
%%                            simplify_return => boolean(), parent => atom(),
%%                            children => boolean(),
%%                            sequence_children => fun((any()) -> any()),
%%                            transform => fun((any()) -> any()),
%%                            syntax_lib => SyntaxLib::module(),
%%                            node => NodeType, formatter => module() }.
%%
%% <dl><dt>TraverseStyle = pre | post | leaf | all | list, How to traverse ast</dt>
%% <dd><ul>
%%   <li>pre : Traverse parent ast first, then its subtrees.</li>
%%   <li>post : Traverse ast subtrees first, then traverse new parent ast generated by new subtrees.</li>
%%   <li>leaf : Only traverse ast leaf.</li>
%%   <li>all : Traverse parent ast first, then its subtress, then traverse new parent ast generated by new subtrees.</li>
%%   <li>list : Only traverse one level subtrees of ast.</li>
%% </ul></dd>
%% <dt>ParseTransform : only used in map/3 and map_with_state/4, convert the return value of function to parse_transform/2 compatible type.</dt>
%% <dt>SimplyfyReturn : default to false.</dt>
%% <dd><ul>
%% <li>true : Just return the return value if there is no error and warning in traverse</li>
%% <li>false = return full erl_abs_return struct</li>
%% </ul></dd>
%% <dt>Parent = pass to traverse_attr() node tag, default to form.</dt>
%% <dt>Children = boolean(), default to false.</dt>
%% <dd><ul>
%% <li>true = Only traverse children of node, not traverse node its self</li>
%% <li>false = traverse node its self and its children</li>
%% </ul></dd>
%% <dt>SyntaxLib = which syntax lib is used by, default to erl_abs_syntax.</dt>
%% <dt>Formatter = error formatter module which provide format_error/1, default is erl_syntax_traverse</dt>
%% </dl>

-type traverse_opts() :: #{traverse => traverse_style(),
                           parse_transform => boolean(),
                           simplify_return => boolean(), parent => atom(),
                           children => boolean(),
                           sequence_children => fun((any()) -> any()),
                           transform => fun((any()) -> any()),
                           syntax_lib => module(),
                           node => node_type(), formatter => module() }.

-type traverse_error_state() :: #{file => string(), errors => traverse_return_error(), warnings => traverse_return_error(),
                                  file_errors => parse_transform_return_error(), 
                                  file_warnings => parse_transform_return_error()}.

-type node_type() :: attribute | pattern | expression | guard | form.
-type traverse_style() :: traverse_step() | all | list.
-type traverse_step() :: pre | post | leaf.
-type traverse_attr() :: #{step := traverse_step(), node := node_type()}.
-type traverse_fun_return() :: #{'__struct__' := erl_syntax_traverse_fun_return, 
                                 node => traverse_node(), state => traverse_state(),
                                 continue => boolean(),
                                 error => traverse_error(), warning => traverse_error(),
                                 errors => [traverse_error()], warings => [traverse_error()]} |
                               {error, traverse_error()} | {warning, traverse_node(), traverse_error()} |
                               continue | {traverse_node(), traverse_state()} | traverse_node().

-type traverse_return(ReturnType) :: ReturnType | 
                                     {ok, ReturnType, traverse_error_state()} |
                                     {error, traverse_error_state()}.

-type traverse_final_return(ReturnType) :: traverse_return(ReturnType) | parse_transform_return(ReturnType).

-type parse_transform_return(ReturnType) :: ReturnType |  {warning, ReturnType, parse_transform_return_error()} |
                                            {error, parse_transform_return_error(), parse_transform_return_error()}.

-type traverse_fun() :: fun((traverse_node(), traverse_attr()) -> traverse_fun_return()).
-type traverse_state_fun() :: fun((traverse_node(), traverse_state(), traverse_attr()) -> traverse_fun_return()).
-type parse_transform_module() :: module().
-type compile_file() :: string().
-type line() :: integer().
-type traverse_return_error() :: [{line(), parse_transform_module(), traverse_error()}].
-type parse_transform_return_error() :: [{compile_file(), traverse_return_error()}].

%%===================================================================
%% API
%%===================================================================
-spec map(traverse_fun(), Node) -> traverse_final_return(Node).
%% @see map/3
map(F, TopNode) ->
    map(F, TopNode, #{}).

-spec reduce(traverse_state_fun(), State, _Node) -> traverse_return(State).
%% @see reduce/4
reduce(F, Init, TopNode) ->
    reduce(F, Init, TopNode, #{}).

-spec map_with_state(traverse_state_fun(), State, Node) -> traverse_final_return({Node, State}).
%% @see map_with_state/4
map_with_state(F, Init, Form) ->
    map_with_state(F, Init, Form, #{}).

-spec mapfold(traverse_state_fun(), State, Node) -> traverse_return({Node, State}).
%% @see mapfold/4
mapfold(F, TopAst, Node) ->
    mapfold(F, TopAst, Node, #{}).

%% @spec map(traverse_fun(), TopAstA, Opts) -> traverse_final_return(TopAstB)
%%           traverse_fun() = fun((AstNodeA, Attr) -> traverse_fun_return(AstNodeB))
%% @doc
%% Takes a function from AstNodeA, {@link traverse_attr()} to AstNodeB, and a TopAstA and produces a TopAstB by applying the function to every subtree in the AST. This function is used to obtain the return values.
%% @see mapfold/4
-spec map(traverse_fun(), Node, traverse_opts()) -> traverse_final_return(Node).
map(F, TopAst, Opts) ->
    F1 = fun(Node, _State, Attr) ->
                 Return = F(Node, Attr),
                 erl_abs_walk_return:new(fun() -> #{node => Return} end, Return)
         end,
    map_with_state(F1, ok, TopAst, Opts).

%% @spec reduce(traverse_state_fun(), Acc0, TopAst, Opts) -> traverse_return(Acc1)
%%              traverse_state_fun() = fun((AstNode, AccA, Attr) -> traverse_fun_return(AccB))
%% @doc
%% Calls F(AstNode, AccIn, Attr) on successive subtree AstNode of TopAst, starting with AccIn == Acc0. F/3 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the TopAst is empty.
%% @see mapfold/4
-spec reduce(traverse_state_fun(), State, _Node, traverse_opts()) -> traverse_return(State).
reduce(F, Acc0, TopAst, Opts) ->
    NF = fun(Node, State, Attr) ->
                 Return = F(Node, State, Attr),
                 erl_abs_walk_return:new(fun() -> #{state => Return} end, Return)
         end,
    Transform = fun({_NNode, State}) -> State end,
    mapfold(NF, Acc0, TopAst, merge_transform(Transform, Opts)).

%% @spec map_with_state(traverse_state_fun(), Acc0, TopAst0, Opts) -> traverse_final_return(TopAst1)
%%                      traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass, and drops Acc1.
%% @see mapfold/4
-spec map_with_state(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_final_return({Node, State}).
map_with_state(F, Acc0, TopAst, Opts) ->
    Transform = fun({NNode, _State}) -> NNode end,
    mapfold(F, Acc0, TopAst, merge_transform(Transform, Opts)).

merge_transform(Transform, #{transform := Transform1} = Opts) ->
    Transform2 = 
        fun(Data) ->
            Transform1(Transform(Data))
        end,
    Opts#{transform => Transform2};
merge_transform(Transform, #{} = Opts) ->
    Opts#{transform => Transform}.

%% @spec mapfold(traverse_state_fun(), Acc0, TopAst0, traverse_opts()) -> traverse_return({TopAst1, Acc1})
%%               traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass.
-spec mapfold(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_return({Node, State}).
mapfold(F, Init, TopAst, Opts) ->
    Formatter = maps:get(formatter, Opts, ?MODULE),
    Opts1 = maps:without([simplify_return, transform, parse_transform, formatter], Opts),
    NF = erl_abs_traverse_m:transform_mapfold_f(F),
    TopAstM = map_m(NF, TopAst, Opts1),
    Return = erl_abs_traverse_m:run(TopAstM, Formatter, Init),
    transform_return(Return, Opts).

transform_return(Return, Opts) ->
    Return1 =
        case maps:find(transform, Opts) of
            {ok, Transform} ->
                erl_abs_monad:lift_m(Transform, Return);
            error ->
                Return
        end,
    case maps:get(parse_transform, Opts, false) of
        true ->
            erl_abs_return:to_compiler(Return1);
        false ->
            case maps:get(simplify_return, Opts, true) of
                true ->
                    Return2 = erl_abs_return:simplify(Return1),
                    Return2;
                false ->
                    Return1
            end
    end.

without_errors(Forms) ->
    map(fun(Node, #{}) -> Node end, Forms, #{traverse => list, formatter => ?MODULE, simplify_return => false}).

-spec map_m(traverse_fun(), Node, traverse_opts()) -> erl_abs_return:struct(Node).
map_m(F, Nodes, Opts) ->
    NF = up_f_by_traverse(F, Opts),
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:listen_nodes(map_m_1(NF, Nodes, Opts)),
      fun({_, Nodes1}) when is_list(Nodes) ->
              erl_abs_traverse_m:return(Nodes1);
         ({_, [Node|_T]}) ->
              erl_abs_traverse_m:return(Node);
         ({_, []}) ->
              erlang:error({no_nodes_return, Nodes})
      end).

up_f_by_traverse(F, #{traverse := pre}) ->
    fun(Node, #{step := pre  } = Attr) -> F(Node, Attr);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_abs_traverse_m:return(Node)
    end;
up_f_by_traverse(F, #{traverse := post}) ->
    fun(Node, #{step := pre  }) -> erl_abs_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post } = Attr) -> F(Node, Attr)
    end;
up_f_by_traverse(F, #{traverse := leaf}) ->
    fun(Node, #{step := pre  }) -> erl_abs_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_abs_traverse_m:return(Node)
    end;
up_f_by_traverse(F, _) ->
    F.

map_m_1(F, Nodes, #{traverse := list} = Opts) when is_list(Nodes) ->
    erl_abs_traverse_m:sequence_all(
      lists:map(
        fun(Node) ->
                map_m_list_node(F, Node, Opts)
        end, Nodes));
map_m_1(F, Nodes, Opts) when is_list(Nodes) ->
    erl_abs_traverse_m:sequence_either(
      lists:map(
        fun(Subtree) ->
                map_m_1(F, Subtree, Opts)
        end, Nodes));
map_m_1(F, NodeA, #{children := true} = Opts) ->
    Opts1 = maps:remove(children, Opts),
    SyntaxLib = syntax_lib(Opts1),
    Subtrees = SyntaxLib:subtrees(NodeA, Opts1),
    erl_abs_traverse_m:as_node(map_m_children(F, NodeA, Subtrees, Opts1, SyntaxLib));
map_m_1(F, NodeA, #{} = Opts) ->
    SyntaxLib = syntax_lib(Opts),
    map_m_tree_node(F, NodeA, Opts, SyntaxLib).

map_m_list_node(_F, {error, Reason}, #{}) ->
    erl_abs_traverse_m:nodes([{error, Reason}]);
map_m_list_node(F, NodeA, Opts) ->
    SyntaxLib = syntax_lib(Opts),
    MA = case SyntaxLib:is_file(NodeA) of
             false ->
                 erl_abs_traverse_m:return(ok);
             {file, File} ->
                 erl_abs_traverse_m:update_file(File)
         end,
    erl_abs_traverse_m:then(MA, apply_f(F, NodeA, #{}, SyntaxLib)).

map_m_tree_node(_F, {error, Reason}, _Opts, _SyntaxLib) ->
    erl_abs_traverse_m:nodes([{error, Reason}]);
map_m_tree_node(F, NodeA, Opts, SyntaxLib) ->
    %% it's not a good way to mix attr with opts.
    Attr = maps:without([traverse], Opts),
    case SyntaxLib:is_file(NodeA) of
        false ->
            NodeType = SyntaxLib:node_type(NodeA, Opts),
            PreType = 
                case SyntaxLib:subtrees(NodeA, Opts) of
                    [] ->
                        leaf;
                    _Subtrees ->
                        pre
                end,
            erl_abs_traverse_m:bind_continue_nodes(
              apply_f(F, NodeA, Attr#{step => PreType, node => NodeType}, SyntaxLib),
              fun(NodeB) ->
                      case SyntaxLib:tps(NodeB, Opts) of
                          {_Type, _Pos, []} ->
                              erl_abs_traverse_m:nodes([NodeB]);
                          {Parent, _Pos, Subtrees} ->
                              erl_abs_traverse_m:bind(
                                map_m_children(F, NodeB, Subtrees, Opts#{parent => Parent}, SyntaxLib),
                                fun(NodeC) ->
                                        erl_abs_traverse_m:set_continue(
                                          apply_f(F, NodeC, Attr#{step => post, node => NodeType}, SyntaxLib), false)
                                end)
                      end
              end);
        {file, File} ->
            erl_abs_traverse_m:then(
              erl_abs_traverse_m:update_file(File),
              apply_f(F, NodeA, Attr#{step => leaf, node => file}, SyntaxLib)
             )
    end.

apply_f(F, Node, Attr, SyntaxLib) ->
    Line = SyntaxLib:get_pos(Node),
    erl_abs_traverse_m:updated_node(
      Node, erl_abs_traverse_m:update_line(Line, F(Node, Attr))).

map_m_children(_F, Node, [], _Opts, _SyntaxLib) ->
    erl_abs_traverse_m:return(Node);

map_m_children(F, Node, Subtrees, Opts, SyntaxLib) ->
    Sequence = maps:get(sequence_children, Opts, fun erl_abs_traverse_m:deep_sequence_m/1),
    Opts1 = maps:remove(sequence_children, Opts),
    SyntaxType = SyntaxLib:type(Node),
    SubtreeMs = m_subtrees(F, Subtrees, Opts1#{parent => SyntaxType}),
    SubtreesM = Sequence(SubtreeMs),
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:listen_updated(SubtreesM),
      fun({_Subtrees1, false}) ->
              erl_abs_traverse_m:return(Node);
         ({Subtrees1, true}) ->
              Node1 = SyntaxLib:update_subtrees(Node, Subtrees1),
              erl_abs_traverse_m:return(Node1)
      end).

%% which syntax_lib used to visit type and subtrees 
syntax_lib(#{syntax_lib := SyntaxLib}) ->
    SyntaxLib;
syntax_lib(#{}) ->
    erl_abs_syntax.

m_subtrees(_F, {skip, Subtrees}, _Opts) when is_list(Subtrees) ->
    lists:map(
      fun(Subtree) ->
              erl_abs_traverse_m:node(Subtree)
      end, Subtrees);
m_subtrees(_F, {skip, Subtree}, _Opts) ->
    erl_abs_traverse_m:node(Subtree);
m_subtrees(F, {transformer, Subtree, Transformer}, Opts) ->
    erl_abs_traverse_m:bind(
      erl_abs_traverse_m:deep_sequence_m_1(m_subtrees(F, Subtree, Opts)),
      fun(Subtree1) ->
              Transformed = Transformer(Subtree1),
              erl_abs_traverse_m:nodes(Transformed)
      end);
m_subtrees(F, {up_attr, Attr, Subtree}, Opts) when is_map(Attr) ->
    Opts1 = maps:merge(Opts, Attr),
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, {up_node, Node, Subtree}, Opts) when is_atom(Node) ->
    Opts1 = Opts#{node => Node},
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, Subtrees, Opts) when is_list(Subtrees) ->
    lists:map(
      fun(Subtree) ->
              m_subtrees(F, Subtree, Opts)
      end, Subtrees);
m_subtrees(F, Subtree, Opts) ->
    map_m_1(F, Subtree, Opts).

format_error({validate_key_failure, required, Key, _Value}) ->
    io_lib:format("option key ~p is required", [Key]);
format_error({validate_key_failure, {invalid_validator, Validator}, Key, _Value}) ->
    io_lib:format("validator ~p for option key ~p is invalid", [Validator, Key]);
format_error({validate_key_failure, {invalid_validator_arg, {Validator, Arg}}, Key, _Value}) ->
    io_lib:format("argument ~p of validator ~p for option key ~p is invalid", [Arg, Validator, Key]);
format_error({validate_key_failure, {invalid_validator_arg, Validator}, Key, _Value}) when is_atom(Validator) ->
    io_lib:format("argument of validator ~p for option key ~p is empty", [Validator, Key]);
format_error({validate_key_failure, {invalid_value, Validator}, Key, Value}) ->
    io_lib:format("validator ~p for option key ~p's value ~p failed", [Validator, Key, Value]);
format_error({validate_key_failuer, {invalid_validator_return, Validator, Return}, Key, _Value}) ->
    io_lib:format("validator ~p for option key ~p returns a invalid_value ~p", [Validator, Key, Return]);
format_error({invalid_option_value, Value}) ->
    io_lib:format("~p is not a valid option value", [Value]);
format_error(Message) ->
    case io_lib:deep_char_list(Message) of
        true -> Message;
        _    -> io_lib:write(Message)
    end.
