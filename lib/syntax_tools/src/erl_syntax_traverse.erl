%%-------------------------------------------------------------------
%% @author Chen Slepher <slepheric@gmail.com>
%% @copyright (C) 2017, Chen Slepher
%% Created : 18 Sep 2017 by Chen Slepher <slepheric@gmail.com>
%% @end
%%-------------------------------------------------------------------
%% @doc `erl_parse' trees traverse.
%%
%% This module provide a series method to traverse `erl_parse' trees
%% such as {@link map/3}, {@link reduce/3}, {@link map_with_state/4}, {@link mapfold/4}.
-module(erl_syntax_traverse).

-include("erl_syntax_struct_name.hrl").

%% API
-export([map/2, map/3]).
-export([map_with_state/3, map_with_state/4]).
-export([reduce/3, reduce/4]).
-export([mapfold/3, mapfold/4]).
-export([without_errors/1]).
-export([map_m/3]).
-export([format_error/1]).

-type traverse_node() :: tuple().
-type traverse_error() :: term().
-type traverse_state() :: term().

%%  @type traverse_opts() = #{traverse => TraverseStyle::traverse_style(),
%%                           parse_transform => ParseTransform::boolean(),
%%                           simplify_return => boolean(), parent => atom(),
%%                           match_right_first => boolean(),
%%                           children => boolean(),
%%                           sequence_children => fun((any()) -> any()),
%%                           transform => fun((any()) -> any()),
%%                           syntax_lib => SyntaxLib::module(),
%%                           node => node_type(), formatter => module() }.
%%
%% <dl><dt>TraverseStyle = pre | post | leaf | all | list, How to traverse ast</dt>
%% <dd><ul>
%%   <li>pre : Traverse parent ast first, then its subtrees.</li>
%%   <li>post : Traverse ast subtrees first, then traverse new parent ast generated by new subtrees.</li>
%%   <li>leaf : Only traverse ast leaf.</li>
%%   <li>all : Traverse parent ast first, then its subtress, then traverse new parent ast generated by new subtrees.</li>
%%   <li>list : Only traverse one level subtrees of ast.</li>
%% </ul></dd>
%% <dt>ParseTransform : only used in map/3 and map_with_state/4, convert the return value of function to parse_transform/2 compatible type.</dt>
%% <dt>SimplyfyReturn : default to false.</dt>
%% <dd><ul>
%% <li>true : Just return the return value if there is no error and warning in traverse</li>
%% <li>false = return full erl_syntax_base_m struct</li>
%% </ul></dd>
%% <dt>Parent = pass to traverse_attr() node tag, default to form.</dt>
%% <dt>Children = boolean(), default to false.</dt>
%% <dd><ul>
%% <li>true = Only traverse children of node, not traverse node its self</li>
%% <li>false = traverse node its self and its children</li>
%% </ul></dd>
%% <dt>SyntaxLib = which syntax lib is used by, default to erl_syntax_wrapper.</dt>
%% <dt>Formatter = error formatter module which provide format_error/1, default is erl_syntax_traverse</dt>
%% </dl>

-type traverse_opts() :: #{traverse => traverse_style(),
                           parse_transform => boolean(),
                           simplify_return => boolean(), parent => atom(),
                           match_right_first => boolean(),
                           children => boolean(),
                           sequence_children => fun((any()) -> any()),
                           transform => fun((any()) -> any()),
                           syntax_lib => module(),
                           node => node_type(), formatter => module() }.

-type traverse_error_state() :: #{file => string(), errors => traverse_return_error(), warnings => traverse_return_error(),
                                  file_errors => parse_transform_return_error(), 
                                  file_warnings => parse_transform_return_error()}.

-type node_type() :: attribute | pattern | expression | guard | form.
-type traverse_style() :: traverse_step() | all | list.
-type traverse_step() :: pre | post | leaf.
-type traverse_attr() :: #{step := traverse_step(), node := node_type()}.
-type traverse_fun_return() :: #{'__struct__' := erl_syntax_traverse_fun_return, 
                                 node => traverse_node(), state => traverse_state(),
                                 continue => boolean(),
                                 error => traverse_error(), warning => traverse_error(),
                                 errors => [traverse_error()], warings => [traverse_error()]} |
                               {error, traverse_error()} | {warning, traverse_node(), traverse_error()} |
                               continue | {traverse_node(), traverse_state()} | traverse_node().

-type traverse_return(ReturnType) :: ReturnType | 
                                     {ok, ReturnType, traverse_error_state()} |
                                     {error, traverse_error_state()}.

-type traverse_final_return(ReturnType) :: traverse_return(ReturnType) | parse_transform_return(ReturnType).

-type parse_transform_return(ReturnType) :: ReturnType |  {warning, ReturnType, parse_transform_return_error()} |
                                            {error, parse_transform_return_error(), parse_transform_return_error()}.

-type traverse_fun() :: fun((traverse_node(), traverse_attr()) -> traverse_fun_return()).
-type traverse_state_fun() :: fun((traverse_node(), traverse_state(), traverse_attr()) -> traverse_fun_return()).
-type parse_transform_module() :: module().
-type compile_file() :: string().
-type line() :: integer().
-type traverse_return_error() :: [{line(), parse_transform_module(), traverse_error()}].
-type parse_transform_return_error() :: [{compile_file(), traverse_return_error()}].

%%===================================================================
%% API
%%===================================================================
-spec map(traverse_fun(), Node) -> traverse_final_return(Node).
%% @see map/3
map(F, TopNode) ->
    map(F, TopNode, #{}).

-spec reduce(traverse_state_fun(), State, _Node) -> traverse_return(State).
%% @see reduce/4
reduce(F, Init, TopNode) ->
    reduce(F, Init, TopNode, #{}).

-spec map_with_state(traverse_state_fun(), State, Node) -> traverse_final_return({Node, State}).
%% @see map_with_state/4
map_with_state(F, Init, Form) ->
    map_with_state(F, Init, Form, #{}).

-spec mapfold(traverse_state_fun(), State, Node) -> traverse_return({Node, State}).
%% @see mapfold/4
mapfold(F, TopAst, Node) ->
    mapfold(F, TopAst, Node, #{}).

%% @spec map(traverse_fun(), TopAstA, Opts) -> traverse_final_return(TopAstB)
%%           traverse_fun() = fun((AstNodeA, Attr) -> traverse_fun_return(AstNodeB))
%% @doc
%% Takes a function from AstNodeA, {@link traverse_attr()} to AstNodeB, and a TopAstA and produces a TopAstB by applying the function to every subtree in the AST. This function is used to obtain the return values.
%% @see mapfold/4
-spec map(traverse_fun(), Node, traverse_opts()) -> traverse_final_return(Node).
map(F, TopAst, Opts) ->
    F1 = fun(Node, State, Attr) ->
                 WalkReturn = F(Node, Attr),
                 map_walk_return(fun(NNode) -> {NNode, State} end, WalkReturn)
         end,
    map_with_state(F1, ok, TopAst, Opts).

%% @spec reduce(traverse_state_fun(), Acc0, TopAst, Opts) -> traverse_return(Acc1)
%%              traverse_state_fun() = fun((AstNode, AccA, Attr) -> traverse_fun_return(AccB))
%% @doc
%% Calls F(AstNode, AccIn, Attr) on successive subtree AstNode of TopAst, starting with AccIn == Acc0. F/3 must return a new accumulator, which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the TopAst is empty.
%% @see mapfold/4
-spec reduce(traverse_state_fun(), State, _Node, traverse_opts()) -> traverse_return(State).
reduce(F, Acc0, TopAst, Opts) ->
    NF = fun(Node, State, Attr) ->
                 WalkReturn = F(Node, State, Attr),
                 map_walk_return(fun(NState) -> {Node, NState} end, WalkReturn)
         end,
    Transform = fun({_NNode, State}) -> State end,
    mapfold(NF, Acc0, TopAst, Opts#{transform => Transform}).

%% @spec map_with_state(traverse_state_fun(), Acc0, TopAst0, Opts) -> traverse_final_return(TopAst1)
%%                      traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass, and drops Acc1.
%% @see mapfold/4
-spec map_with_state(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_final_return({Node, State}).
map_with_state(F, Acc0, TopAst, Opts) ->
    Transform = fun({NNode, _State}) -> NNode end,
    mapfold(F, Acc0, TopAst, Opts#{transform => Transform}).

%% @spec mapfold(traverse_state_fun(), Acc0, TopAst0, traverse_opts()) -> traverse_return({TopAst1, Acc1})
%%               traverse_state_fun() = fun((AstNodeA, AccA, Attr) -> traverse_fun_return({AstNodeB, AccB}))
%% @doc
%% Combines the operations of map/3 and reduce/4 into one pass.
-spec mapfold(traverse_state_fun(), State, Node, traverse_opts()) -> traverse_return({Node, State}).
mapfold(F, Init, Node, Opts) ->
    Opts1 = maps:without([simplify_return, transform_return], Opts),
    Return = mapfold_1(F, Init, Node, Opts1),
    transform_return_m(Return, Opts).

without_errors(Forms) ->
    map(fun(Node, #{}) -> Node end, Forms, #{traverse => list, formatter => ?MODULE, simplify_return => false}).

-spec map_m(traverse_fun(), Node, traverse_opts()) -> erl_syntax_monad:monadic(M, Node) when M :: erl_syntax_monad:monad().
map_m(F, Nodes, Opts) ->
    NOpts = update_opts(Opts),
    NF = transform_f(F, NOpts),
    erl_syntax_traverse_m:bind(
      erl_syntax_traverse_m:pop_nodes(map_m_1(NF, Nodes, Opts)),
      fun(Nodes1) when is_list(Nodes) ->
              erl_syntax_traverse_m:return(Nodes1);
         ([Node|_T]) ->
              erl_syntax_traverse_m:return(Node);
         ([]) ->
              erlang:error({no_nodes_return, Nodes})
      end).

format_error(Message) ->
    io:format("get message ~p~n", [Message]),
    case io_lib:deep_char_list(Message) of
        true -> Message;
        _    -> io_lib:write(Message)
    end.
%%====================================================================
%% Internal functions
%%====================================================================
mapfold_1(F, Init, Node, #{} = Opts) ->
    NF = erl_syntax_traverse_m:transform_mapfold_f(F),
    NodeM = map_m(NF, Node, Opts),
    Formatter = maps:get(formatter, Opts, ?MODULE),
    erl_syntax_traverse_m:run(NodeM, Formatter, Init).

map_m_1(F, Nodes, #{traverse := list} = Opts) ->
    map_m_list(F, Nodes, Opts);
map_m_1(F, Nodes, Opts) when is_list(Nodes) ->
    erl_syntax_traverse_m:sequence_either(
      lists:map(
        fun(Subtree) ->
                map_m_1(F, Subtree, Opts)
        end, Nodes));
map_m_1(F, NodeA, #{children := true} = Opts) ->
    Opts1 = maps:remove(children, Opts),
    erl_syntax_traverse_m:as_node(map_m_children(F, NodeA, Opts1));
map_m_1(F, NodeA, #{} = Opts) ->
    SyntaxLib = syntax_lib(Opts),
    map_m_tree(F, NodeA, Opts, SyntaxLib).

map_m_list(F, Nodes, #{} = Opts) when is_list(Nodes) ->
    erl_syntax_traverse_m:sequence_all(
      lists:map(
        fun(Subtree) ->
                map_m_list(F, Subtree, Opts)
        end, Nodes));
map_m_list(_F, {error, Reason}, #{}) ->
    erl_syntax_traverse_m:then(
      erl_syntax_traverse_m:formatted_errors([Reason]),
      erl_syntax_traverse_m:nodes([]));
map_m_list(F, NodeA, Opts) ->
    SyntaxLib = syntax_lib(Opts),
    MA = case SyntaxLib:is_file(NodeA) of
             false ->
                 erl_syntax_traverse_m:return(ok);
             {file, File} ->
                 erl_syntax_traverse_m:update_file(File)
         end,
    erl_syntax_traverse_m:then(MA, apply_f(F, NodeA, #{}, SyntaxLib)).

map_m_tree(_F, {error, Reason}, _Opts, _SyntaxLib) ->
    erl_syntax_traverse_m:then(
      erl_syntax_traverse_m:formatted_errors([Reason]),
      erl_syntax_traverse_m:nodes([]));
map_m_tree(F, NodeA, Opts, SyntaxLib) ->
    Attr = maps:without([traverse, parse_transform, monad, monad_class, formatter], Opts),
    case SyntaxLib:is_file(NodeA) of
        false ->
            NodeType = SyntaxLib:node_type(NodeA, Opts),
            PreType = 
                case SyntaxLib:subtrees(NodeA, Opts) of
                    [] ->
                        leaf;
                    _Subtrees ->
                        pre
                end,
            erl_syntax_traverse_m:bind_continue_nodes(
              apply_f(F, NodeA, Attr#{step => PreType, node => NodeType}, SyntaxLib),
              fun(NodeB) ->
                      case SyntaxLib:tps(NodeB, Opts) of
                          {_Type, _Pos, []} ->
                              erl_syntax_traverse_m:nodes([NodeB]);
                          {Parent, _Pos, Subtrees} ->
                              erl_syntax_traverse_m:bind(
                                map_m_children(F, NodeB, Subtrees, Opts#{parent => Parent}, SyntaxLib),
                                fun(NodeC) ->
                                        erl_syntax_traverse_m:set_continue(
                                          apply_f(F, NodeC, Attr#{step => post, node => NodeType}, SyntaxLib), false)
                                end)
                      end
              end);
        {file, File} ->
            erl_syntax_traverse_m:then(
              erl_syntax_traverse_m:update_file(File),
              apply_f(F, NodeA, Attr#{step => leaf, node => file}, SyntaxLib)
             )
    end.

apply_f(F, Node, Attr, SyntaxLib) ->
    Line = SyntaxLib:get_pos(Node),
    erl_syntax_traverse_m:updated_node(
      Node, erl_syntax_traverse_m:update_line(Line, F(Node, Attr))).

map_m_children(F, Node, Opts) ->
    SyntaxLib = syntax_lib(Opts),
    Subtrees = SyntaxLib:subtrees(Node, Opts),
    map_m_children(F, Node, Subtrees, Opts, SyntaxLib).

map_m_children(_F, Node, [], _Opts, _SyntaxLib) ->
    erl_syntax_traverse_m:return(Node);

map_m_children(F, Node, Subtrees, Opts, SyntaxLib) ->
    SyntaxType = SyntaxLib:type(Node),
    erl_syntax_traverse_m:bind(
      erl_syntax_traverse_m:listen_updated(map_m_subtrees(F, Subtrees, Opts#{parent => SyntaxType})),
      fun({_Subtrees1, false}) ->
              erl_syntax_traverse_m:return(Node);
         ({Subtrees1, true}) ->
              Node1 = SyntaxLib:update_subtrees(Node, Subtrees1),
              erl_syntax_traverse_m:return(Node1)
      end).

%% which syntax_lib used to visit type and subtrees 
syntax_lib(#{syntax_lib := SyntaxLib}) ->
    SyntaxLib;
syntax_lib(#{}) ->
    erl_syntax_wrapper.

map_m_subtrees(F, Nodes, #{sequence_children := Sequence} = Opts) ->
    Opts1 = maps:remove(sequence_children, Opts),
    SubtreesM = m_subtrees(F, Nodes, Opts1),
    Sequence(SubtreesM);
map_m_subtrees(F, Nodes, Opts) ->
    SubtreesM = m_subtrees(F, Nodes, Opts),
    erl_syntax_traverse_m:deep_sequence_m(SubtreesM).

m_subtrees(F, Subtrees, Opts) when is_list(Subtrees) ->
    lists:map(
      fun(Subtree) ->
              m_subtrees(F, Subtree, Opts)
      end, Subtrees);
m_subtrees(_F, {skip, Subtree}, _Opts) ->
    deep_node(Subtree);
m_subtrees(F, {transformer, Subtree, Transformer}, Opts) ->
    erl_syntax_traverse_m:bind(
      map_m_subtrees(F, Subtree, Opts#{sequence_children => fun erl_syntax_traverse_m:deep_sequence_m_1/1}),
      fun(Subtree1) ->
              Transformed = Transformer(Subtree1),
              erl_syntax_traverse_m:nodes(Transformed) 
      end);
m_subtrees(F, {up_attr, Attr, Subtree}, Opts) when is_map(Attr) ->
    Opts1 = maps:merge(Opts, Attr),
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, {up_node, Node, Subtree}, Opts) when is_atom(Node) ->
    Opts1 = Opts#{node => Node},
    m_subtrees(F, Subtree, Opts1);
m_subtrees(F, Subtree, Opts) ->
    map_m_1(F, Subtree, Opts).

deep_node(Nodes) when is_list(Nodes) ->
    lists:map(
      fun(Node) ->
              erl_syntax_traverse_m:node(Node)
      end, Nodes);
deep_node(Node) ->
    erl_syntax_traverse_m:node(Node).



transform_f(F, #{traverse := pre}) ->
    fun(Node, #{step := pre  } = Attr) -> F(Node, Attr);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_syntax_traverse_m:return(Node)
    end;
transform_f(F, #{traverse := post}) ->
    fun(Node, #{step := pre  }) -> erl_syntax_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post } = Attr) -> F(Node, Attr)
    end;
transform_f(F, #{traverse := leaf}) ->
    fun(Node, #{step := pre  }) -> erl_syntax_traverse_m:return(Node);
       (Node, #{step := leaf } = Attr) -> F(Node, Attr);
       (Node, #{step := post }) -> erl_syntax_traverse_m:return(Node)
    end;
transform_f(F, _) ->
    F.

map_walk_return(F, WalkReturn) ->
    case WalkReturn of
        #{'__struct__' := ?WALK_RETURN} = Map ->
            Map;
        #{'__struct__' := ?TRAVERSE_M} = Map ->
            Map;
        #{'__struct__' := ?RETURN_OK} = Map ->
            Map;
        #{'__struct__' := ?RETURN_FAIL} = Map ->
            Map;
        {error, Reason} ->
            {error, Reason};
        {ok, WalkReturn} ->
            {ok, F(WalkReturn)};
        WalkReturn ->
            F(WalkReturn)
    end.

transform_return_m(Return, Opts) ->
    Return1 = 
        case maps:find(transform, Opts) of
            {ok, Transform} ->
                erl_syntax_monad:lift_m(Transform, Return, erl_syntax_return_m);
            error ->
                Return
        end,
    case maps:get(parse_transform, Opts, false) of
        true ->
            erl_syntax_return_m:to_compiler(Return1);
        false ->
            case maps:get(simplify_return, Opts, true) of
                true ->
                    erl_syntax_return_m:simplify(Return1);
                false ->
                    Return1
            end
    end.

update_opts(Opts) ->
    maps:merge(#{formatter => ?MODULE, traverse => all}, Opts).